{
  "input": {
    "user_baseline": "I am a Senior Backend Developer (Node.js/Go) comfortable with Linux command line. I use Docker daily: I can write multi-stage Dockerfiles, optimize image sizes, and use docker-compose for local development. However, I have zero experience with orchestration. Concepts like 'Pods,' 'Ingress,' or 'Helm charts' are abstract to me. I understand basic networking (ports, DNS) but find Kubernetes manifests verbose and confusing.",
    "user_objective": "My company is migrating our monolithic app to microservices on a cloud provider. My specific goal is to take three of our existing dockerized microservices (Frontend, API, Database) and deploy them into a live Kubernetes cluster. I need to be able to configure them so they can communicate securely (Service Discovery/Secrets), expose the frontend to the public internet (Ingress), and perform a 'Rolling Update' without downtime. I need to be able to debug if a Pod gets stuck in CrashLoopBackOff."
  },
  "learning_path": {
    "pedagogical_strategy": "The curriculum leverages the user's strong Docker and CLI background by immediately translating familiar concepts (containers, environment variables, networking) into Kubernetes primitives. The sequencing logic is strictly progressive: (1) Establish the basic unit of deployment (Pod/Deployment), (2) Enable internal communication and configuration (Services/Secrets), (3) Enable external access (Ingress), and finally (4) Address operational requirements (Rolling Updates/Debugging). This approach focuses on Minimum Viable Knowledge required to achieve the specific deployment and operational goals.",
    "curriculum": [
      {
        "module_order": 1,
        "title": "Translating Docker to Kubernetes: Pods and Deployments",
        "competency_goal": "The learner will be able to define the fundamental K8s resources (Pod, ReplicaSet, Deployment) and use YAML manifests to deploy a single microservice instance.",
        "mental_map": [
          "The Pod as the atomic unit (the wrapper around one or more containers, replacing the single Docker container mental model).",
          "The Deployment resource: Defining the desired state (which image, how many replicas) and managing the Pod lifecycle.",
          "Basic YAML structure for K8s manifests (apiVersion, kind, metadata, spec).",
          "Essential `kubectl` commands for deployment and status checking (`apply`, `get`, `describe`)."
        ],
        "application": [
          "Write a basic Deployment manifest for the API microservice, specifying the existing Docker image and a single replica.",
          "Apply the manifest to a live cluster using `kubectl apply -f api-deployment.yaml`.",
          "Verify the deployment status and check the running Pod details using `kubectl get pods` and `kubectl describe deployment api`."
        ],
        "relevance_to_goal": "This module establishes the foundational mechanism for getting the existing dockerized services onto the cluster, which is the prerequisite for all subsequent steps."
      },
      {
        "module_order": 2,
        "title": "Internal Service Discovery and Secure Configuration",
        "competency_goal": "The learner will be able to use Services for stable internal communication (Service Discovery) and manage sensitive configuration using Secrets.",
        "mental_map": [
          "The Service resource: Providing a stable, internal DNS name and IP address for a set of Pods (Service Discovery).",
          "Service Types: Understanding ClusterIP (internal-only access) as the default for backend communication.",
          "Selectors: How Services use labels to target the correct Pods managed by a Deployment.",
          "ConfigMaps and Secrets: Storing non-sensitive and sensitive configuration data, respectively, and injecting them into Pods as environment variables or mounted files."
        ],
        "application": [
          "Create a Deployment and a ClusterIP Service for the Database microservice.",
          "Create a K8s Secret containing the database credentials.",
          "Modify the API Deployment manifest to inject the DB credentials from the Secret and the DB hostname (via the ClusterIP Service name) as environment variables.",
          "Use `kubectl exec` into the API Pod to confirm the environment variables are correctly loaded and attempt a basic connection test to the DB Service name."
        ],
        "relevance_to_goal": "This directly addresses the requirement for the services to 'communicate securely (Service Discovery/Secrets)' by establishing stable internal networking and secure configuration injection."
      },
      {
        "module_order": 3,
        "title": "External Access and Routing with Ingress",
        "competency_goal": "The learner will be able to expose the Frontend service to the public internet using a LoadBalancer Service and define an Ingress resource for HTTP routing.",
        "mental_map": [
          "Service Types for External Access: LoadBalancer (for simple, direct exposure) vs. NodePort.",
          "The Ingress resource: Defining rules (hostnames, paths) to route external HTTP/S traffic to internal Services.",
          "The role of the Ingress Controller (conceptual understanding that it handles the actual routing based on the Ingress resource definition)."
        ],
        "application": [
          "Create a Deployment for the Frontend microservice.",
          "Define a LoadBalancer Service for the Frontend Deployment to obtain an external IP address.",
          "Define an Ingress resource that specifies a simple host rule (e.g., `frontend.company.com`) and routes traffic to the Frontend Service on the correct port.",
          "Verify the external IP/hostname is available and confirm the Frontend is accessible via the Ingress route."
        ],
        "relevance_to_goal": "This fulfills the core requirement to 'expose the frontend to the public internet' using the standard K8s mechanism for HTTP routing."
      },
      {
        "module_order": 4,
        "title": "Operational Readiness, Rolling Updates, and Debugging",
        "competency_goal": "The learner will be able to configure Deployments for zero-downtime updates and efficiently diagnose common operational failures like CrashLoopBackOff.",
        "mental_map": [
          "Deployment Strategy: Understanding the default `RollingUpdate` mechanism and how it ensures availability during updates.",
          "Readiness and Liveness Probes: Defining health checks to signal when a Pod is ready to receive traffic (Readiness) and when it needs to be restarted (Liveness).",
          "The K8s Debugging Flow: Using `kubectl logs`, `kubectl describe pod`, and `kubectl get events` to trace the lifecycle and failure points of a Pod."
        ],
        "application": [
          "Modify the API Deployment to include basic HTTP readiness and liveness probes.",
          "Perform a simulated version upgrade (e.g., changing the image tag) on the API Deployment using `kubectl set image` and observe the rolling update process to confirm zero downtime.",
          "Intentionally introduce a configuration error (e.g., a bad environment variable) into a new Pod definition, observe the resulting `CrashLoopBackOff` status.",
          "Use the K8s debugging flow (`kubectl describe pod`, `kubectl logs`) to identify the root cause of the simulated `CrashLoopBackOff`."
        ],
        "relevance_to_goal": "This module directly addresses the final operational requirements: 'perform a 'Rolling Update' without downtime' and 'debug if a Pod gets stuck in CrashLoopBackOff'."
      }
    ]
  }
}